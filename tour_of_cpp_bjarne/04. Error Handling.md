This chapter covers:
* Exceptions
* Invariants
* Error-handling Alternatives
* Assertions
	*  `assert()`; `static_assert`; `noexcept`

## 4.2 Exception
Consider a situation where we try to access an element that is out of the range for the vector in [2.3 Classes](02.%20User-Defined%20Types.md#2.3%20Classes). Assuming an out of range access  is a kind of error we would like to recover from, the solution will be the `Vector` implementer to detect the attempted error and tell the user about it.

For example it can be detected and an `out_of_range` exception can be thrown:
```c++
double& Vector::operator[](int s)
{
	if (!(s>=0 && s<size()))
		throw out_of_range("Vector::opertor[]");
	return elem[s];
}
```
The `throw` transfers control to a handler for exceptions of type `out_of_range` in some function that directly or indirectly called `Vector::opertor[]()`

This is how an exception can be handled:
```c++
void f(Vector& v)
{
	try {
		compute1(v);             // might access beyond v range
		Vector v2 = compute2(v); // might access beyond v range 
		compute3(v2);            // might access beyond v3 range
	}
	catch (const out_of_range& err) {
		// handle error
		cout << err.what() << '\n';
	}
}
```
We should always place a try and catch block in places where its appropriate to handle such exception not where deemed inappropriate.

The `out_of_range` exception is defined in the standard library’s `<stdexcept>`. The `what()` function prints the error message of the exception object.

Bjarne introduces a “main technique” for making error handling simple and systematic (called *Resource Acquisition is Initialization: RAII*) explained in 5.2.2

The basic idea of RAII is for a constructor to acquire all resources required for it to operate, and have the destructor release all resources, thus making resource release guaranteed and implicit 

## 4.3 Invariants 

### half-open range
The `[a:b)` notation specifies a half-open range; meaning a is part of the range but be is not

Whenever we define a function, we should consider what its preconditions are and consider whether to test them. For most applications it is a good idea to test simple invariants.

in the Vector class in [2.3 Classes](02.%20User-Defined%20Types.md#2.3%20Classes) although its rendition in [4.2 Exception](04.%20Error%20Handling.md#4.2%20Exception) enforces the invariant statement “only elements within vectors range can be accessed”, nothing it does makes any sense unless the members of Vector have “reasonable” values. We did state in vectors declaration that “elem points to an array of sz doubles”, such a statement of what is assumed to be true for a class is known as a *class invariant*.

It is the job of a classes constructor to enforce this invariant so its members can rely on them efficiently, likewise its is the role of the member functions to make sure the invariant holds when they exit.

The constructor of the vector class defined in [2.3 Classes](02.%20User-Defined%20Types.md#2.3%20Classes) only partially did its job; It properly initialized its members, but failed to check if the arguments made sense.

Consider:
```c++
Vector v(-27);
```
This is very error-prone.

Here is a more appropriate definition for the constructor class in [2.3 Classes](02.%20User-Defined%20Types.md#2.3%20Classes) :
```c++
Vector::vector(int s)
{
	if (s<0)
		throw length_error("Vector constructor: negative size");
	elem = new double[s];
	sz = s;
}
```

### When the `new` operator can’t find memory to allocate
when this happen it throws `std::bad_alloc`.  So we can now write:
```c++
void test(int n)
{
	try {
		Vector v(n);
	}
	catch (const std::lengh_error& err) {
	}
	catch (const std::bad_alloc& err) {
	}
}

void run()
{
	test(-27);             // throws length_error
	test(1'000'000'000);   // might throw bad_alloc (depends on machine)
	test(10);              // should be OK.
}
```
Memory exhaustion occurs if you ask for more memory than the machine offers or if your program already has consumed almost that much and your request pushes it over the limit.

We can define our own classes to be used as exceptions and have them carry as much information as we want.

Often a function has no way of completing its assigned task after an execution is thrown. Then “handling” an exception means doing some minimal local cleanup and re-throwing the exception. An example:
```c++
void test(int n)
{
	try {
		Vector v(n);
	}
	catch (std::length_error err&) {
		cerr << "test failed; length error\n";
		throw;  // rethrow
	}
	catch (std::bad_alloc&) {
		std::terminate();    // terminate program
	}
}
```

According to Bjarne: in well designed code `try`-blocks are rare. He says we should avoid overuse by systematically using RAII technique which will be covered in chapter 5 and 6

The notion of invariants is central to the design of classes, and preconditions serve a similar role in the design of functions:
* invariants helps us understand what we want precisely.
* Its forces specificity

## Error-Handling Alternatives
in C++ exceptions are designed to be used to report failure to complete a given task. Exceptions are integrated with constructors and destructors to provide a coherent framework for error handling and resource management.

Compilers are optimized to make returning a value much cheaper than throwing the same value as an exception.

Throwing an exception is not the only way of reporting an error that cannot be handled locally. A function can indicate that it cannot perform its allotted task by:
* throwing an exception
* somehow returning a value indicating failure
* terminating the program (`std::terminate`, `std::exit()`, `std::abort()`)

### We return an error indicator (an “error code“) when:
*  A failure is normal and expected
* An immediate caller can reasonable be expected to handle the failure.
* An error happens in a set of parallel tasks and we need to know which one.
* A system has so little memory that the run-time support for the exceptions would crowd out essential functionality

### We throw exceptions when:
* An error is so rare that  a programmer is likely to forget to check for it
* An error cannot be handled by an immediate caller.
* New kinds of errors can be added in lower-modules of an application so that higher level modules are not written to cope with such errors.
* No suitable return path for error codes is available. For example: a constructor does not have a return value for a “caller” to check. Similarly an operator doesn’t usually have an obvious return path for codes. For example: `a*b+c/d`
* The return path of a function is made more complicated or more expensive by a need to pass both a value and an error-indicator (a `pair`)
* The recovery of errors depend on the result of several function calls, leading to the need to maintain local state between calls and complicated control structures.
* The function that found the error was a callback (a function argument)
* An error implies that some “undo action” is needed

### We terminate when:
* An error is a of a kind we cannot recover from; e.g: memory exhaustion
* The system is one where error-handling is based on restarting a thread, process or computer whenever a non-trivial error is detected.

### `noexcept` Keyword
One way to ensure termination is to add `noexcept` to a function so that a throw form anywhere in the functions implementation will turn into a `terminate()`. Note that there are applications that can’t accept unconditional terminations, so alternatives must be used.

**RAII** is essential for simple and efficient error-handling using exceptions. Code littered with `try`-blocks often simply reflects the worst aspects of error-handling strategies conceived for error codes.

## 4.5 Assertions
There is currently no general way of writing optimal run-time test of invariants, pre-conditions, etc. For now we have to rely on ad-hoc mechanism. There are many of such mechanism. They need to be flexible, general and imply no cost when not enables. Here is a scheme that Bjarne has used for “assertions”:
```c++
constexpr enum class Error_action {
	logging, throwing, terminating, ignoring};
	
constexpr Error_action default_error_action = action_type::throwing;

constexpr enum class Error_code {length_error, range_error};
string[] error_names = { "length error", "range_error" };

template <Error_action action = Error_action::throwing, class C>
constexpr void expect(C cond, Error_code x)
{
	if(action == Error_action::logging)
		if (!cond()) 
		std::cerr << "expect() failure: " << int(x) << '' <<
		error_code_name[int(x)] << '\n';
	if(action == Error_action::throwing)
		if (!cond()) throw x;
	if(action == Error_action::terminating)
		if (!cond()) std::terminate();
	// nothing implemented for ignoring because we're ignoring
}
```
This mind be mindboggling, however its very flexible, general and trivial to use:
```c++
double& Vector::operator[](int i)
{
	expect([i,this] { i >= 0 && i < size(); }, Error_code::range_error);
	return elem[i];
}
```
`[i, this]{ i >= 0 && i<size(); }` is a lambda; it will be explain in chapter 7.

By setting `default_error_action` a user can set an action suitable for a particular deployments of the program, such as `terminating` or `logging`.

In many systems, its important that an assertion mechanism, such as `expect()` offers a single point of control of the of the meaning of assertion failures. Searching a large code base for if-statements that are really checks of assumptions is typically impractical.

## Note to self
Only use if statements for control logic (and a very minimal scale at that); for invariant enforcement’s (assertions), use assert mechanisms

## 4.5.1 `assert()`
The standard library offers the debug macro, `assert()`, to assert that a condition must hold at runtime. For example.
```c++
void f(const char* p)
{
	assert(p!=nullptr);    // p must not be a nullptr
}
```
if the condition of an `assert()` fails in “debug mode”, the program terminates. if not in debug mode, the `assert()` is not checked. pretty crude an inflexible.

## 4.5.2 Static Assertions
Exceptions report errors found at run time. if an error can be found at compile time, it is usually preferable to do so. We can perform simple checks on most properties that are known at compile time and report failures to meet our expectations as compiler error messages:
```c++
static_assert(4 <= sizeof(int), "integers are to small");
```
This will write `integers are too small` if `4<=sizeof(int)` does not hold; that is, if an `int` on this system does not have at lease 4 bytes. Such statements of expectations are called *assertions*.

The `static_assert` mechanism can be used for anything that can be expressed in terms of constant expressions. For example:
```c++
constexpr double C = 299'792.458;

void d(double speed)
{
	constexpr double local_max = 160.0/(60*60);
	
	static_assert(speed<C, "can't go that fast"); // ERR: speed !constant
	static_assert(local_max<C, "can't go that fast"); // OK
}
```
In general. `static_assert(A,S)` prints S as a compiler error message if `A` is not `true`. if you don want a specific message printed leave out `S`.

One important use of the `static_assert` is to make assertions about types used as parameters in generic programming

## 4.5.3 `noexcept`
A function that should never throw an exception can be declared `noexcept`. For example:
```c++
void user(int sz) noexcept
{
	Vector v{sz};
	iota(&v[0], &v[sz], 1); // fill v with 1,2,3,4
}
```
in the case `user()` still throws, `std::terminate()` is called to immediately terminate the program.

Thoughtlessly sprinkling `noexcept` on functions is hazardous. Like other powerful language features, `noexcept` should be applied with understanding and caution.

## 4.6 Advice
1) Throw an exception to indicate you cannot perform an assigned task
2) use exceptions for error handling only
3) exceptions should only be used for unexpected behaviors
4) use error codes when an immediate caller is expected to handle the error
5) Throw an exception for errors expected to prelocate up through many functions
6) when in doubt to use error codes or exceptions; use exceptions.
7) develop error handling early in design
8) use purpose designed user defined types as exceptions
9) its not important to use std exception class hierarchy
10) prefer RAII to explicit try blocks
11) Let a constructor establish an invariant, and throw if it cannot
12) Design your error-handling strategy around invariants
13) what can be checked at compile time; is usually best checked at compile time.
14) use an assertion mechanism to provide a single point of control of the meaning of failure;
15) if your function may not throw, declare it `noexcept`
16) don’t apply `noexcept` thoughtlessly
