This chapter informally presents the notation of C++ and its model of memory and computation.

## 1.2 Programs
C++ is  a compiled languages, for a program to run, it’s source text has to be processed by a compiler producing object files, which are combined by a linker yielding an executable program.

Compilation and execution of c++ programs are platform specific; its is not portable.
What is portable is its source code.

The ISO C++ standard libraries defines 2 kind of entities:
1) Core language features
2) Standard-library components: such as containers and I/O operations

C++ is statically typed language. That is, the type of every entity must be known to the compiler at its point of use. The type of an object determines the set of operations applicable to it an its layout in memory.

## 1.2.1 Hello World!
```c++
int main() {}
```
Every c++ program must have exactly one global function named `main()`. The program starts by executing that function. 

The `int` value return by the main function is the value returned to “the System”. If no value is returned the system will receive a value indicating successful completion. A non-zero value indicates failure.

Not every environment makes use of the main functions returned `int`, Linux/Unix based systems do use it, Windows based rarely do.

Here is a program that produces some output:
```c++
import std;

int main() 
{
	std::cout << "Hello World\n";
}
```
The `import` keyword  instructs the compiler to make the declarations of the standard library available. `std::` specifies that the name `cout` is to be found in the standard-library namespace. 

The `import` directive is new feature from c++20, if troubles are experiences with this directive; the conventional `#include <iostream>` can be used.

```java
import std;
using namespace std;

double square(double x) { return x*x; }

void print_square(double x) {
	cout << "The square of " << x << "is" << square(x) << "\n";
}

int main() { print_square(1.234) };
```

## 1.3 Functions
Things are done in c++ by calling functions. A function cannot be called unless its declared.

A functions declaration give the name of the function, the type of the value returned (if any) and the number and types of arguments that must be supplied in a call.
```c++
Elem* next_elem();
```
In a function declaration the semantics of argument passing are identical to the semantics of initialization: This means argument types are checked and implicit argument type conversion takes place when necessary.

This mean when passing values to an argument treat the arguments like your initializing variables for the called functions’ usage, not following the laws governing how said variable should be initialized (e.g using the wrong type or what not) is illegal and would lead to an error.

In function declarations may contain argument names: unless the function declaration is also a function definition the compiler simply ignores those names:
```c++
void function(double d);
// the above declaration is the same as the belown one to the compiler
void function(double)
```

The type of function is consists of the return type followed by the sequence of its argument types in parentheses:
```c++
double get(const vector<double>& vec, int index)

its type is below:

double(const vector<double>&, int);
```
Function can be a member of a class. For such a member function, the name of its class is also part of the function type; for example:
```c++
char& String::operator[](int index);

its type is below:

char& String::(int);
```

> **According to Bjarne;** the number of errors in code correlates strongly with the amount of code and the complexity of the code, such problems can be addressed using more and shorter functions. The first step to comprehensibility, which itself is the first step to maintainability, is to break computational tasks into meaningful chunks (represented as functions and classes) and name those. such functions provide the basic vocabulary of computation, just as the types (built-in and user-defined) provide the basic vocabulary of data.

### Overloading
C++ can *overload functions*:
```c++
void print(int);
void print(double);
void print(String);

void user() 
{
	print(42);
	print(9.65);
	print("Barcelona");
}
```
if two alternative functions could be called, but neither is better than the other, the call is deemed ambiguous and the compiler gives an error.
an example;
```c++
void print(int, double);
void print(double, int);

void user2() 
{
	print(0, 0); // ERROR: function call ambiguous
}
```

## 1.4 Types, Variables and Arithmetic
Every name and every expression has a type that determines the operations that may be performed on it.

A *declaration* is a statement that introduces and entity into the program and specifies its type: 
* A *Type* defines the set of possible values and a set of operations (for an object)
* An *Object* is a some memory that hods a value of some type.
* A *Value* is a set of bits interpreted according to a type
* A *Variable* is a named object

C++ offers a small zoo of fundamental types, and each of does types are hardware specific; for example: the size of an `int` in some hardware might be 4 bytes and in others 2 or even 8.

### `char` and its roles defining other types
The size of other types are multiples of the size of a `char`. The size of a type varies among different machines. It can be obtained using the `sizeof` operator; for example: `sizeof(char)` is usually 1 and `sizeof(int)` is usually 4.

If we want specific size we can use a standard library alias type, such as `int32_t`

Numbers can be floating types of integers, Things to note:
1) floating-point literals are recognized by a decimal point or an exponent
2) Integer literals are by default decimal, to indicate the base; base prefix are specified `0b101001011` for example uses the base prefix `0b`, `0x` for hexadecimals and `0` for octals
3) Long Number literals readable for humans, we can use the single quote (‘) as a digit separator. For example, `123,456,789,012,345,678,901`; digit separators can be used for both floating-point literals and integers.

## 1.4.1 Arithmetic
Normal arithmetic stuff: The bitwise logical operators yield a result of the operand type for which the operation has been performed on each bit.

Conversions used in expressions are called *usual arithmetic conversions*; its aim is to ensure that expressions are computed at the highest precision of their operands.

## 1.4.2 Initialization
Before an object can be used it must be given a value:
```c++
double d1 = 2.3;  // assignment initialization
double d2 {2.3};  // list initialization
double d3 = {2.3};

vector<int> v {1, 2, 3, 4, 6};
```
List initialization: `type name { values }` should be preferred in C++, it prevents conversions that lose information, An example:
```c++
int i = 7.8; // conversion occurs: 7.8 becomes 7
int j {7.8}; //ERROR; floating-point to integer conversion
```
*Narrowing Conversions* are allowed and implicitly applied when initializing with the assignment operator `=` but not with list initialization.

### Constants
Constants cannot be left uninitialized

### `auto`
When defining a variable you don’t need to state its type explicitly when its type can be deduces from the initializer; this can be achieved using `auto`. `auto`  is used when there is no specific reason to mention the type explicitly
```c++
auto d = 1.2;
auto z = sqrt(y);
auto bb {true};
```
reasons to use `auto`:
* The definition is in a large scope where we want to make the type clearly visible to readers of the code.
* The types of the initializer isn’t obvious
* we want to be explicit about the variables range or precision.
* And avoiding redundancy and writing long type names.

## 1.5 Scope and Lifetime
A declaration introduces its name into a scope:
* **Local scope**: scopes that extends form its point of declaration to the end of the block its declaration occurs: A name declared in a function or in a lambda is *local name*
* **Class scope**: a name is called a member name if its defined inside a class, outside of any function, lambda or `enum class`, its scope its in the block its defined in
* **Namespace scope**: a name is called a namespace member name, its its defined in a namespace, outside any function, lambda, class or `enum class`. its scope is within the namespace.
* A name not declared inside any other construct is called a *global name* and is said to be in the **global namespace**.
* There are also object without names, such as temporaries and object created using `new`

```c++
vector<int> vec; // vec is global

void fct(int arg) // fct is a global
{
	String motto {"Who dares wins"}; // Local name
	auto p = new Record("Hume"); // p points to unamed Record (new)
	
}

struct Record {
	String name; // name is a member of Record
}
```
Things to Note:
* An object must be constructed (initialized) before it is used and will be destroyed at the end of its scope.
* A namespace object point of destruction is the end of the program.
* A members point of destruction is the same as its object point of destruction
* An object created by `new` lives until destroyed by `delete`

## 1.6 Constants
C++ supports two notions of immutability
* **`const`**: This roughly means “I promise not to change this value”, the compiler enforces this promise. `const` may be calculated at runtime.
`const`s are usually used to define interfaces so that data can be passes into functions using pointers or references without fear of being modified
* **`constexpr`**: This roughly means “to be evaluated at compile time”. This specifies constants that allow placement of data in read-only memory (where its is unlikely to be corrupted), and for performance. The value of a `constexpr` must be calculated by the compiler.

examples:
```c++
constexpr int dmv = 17;              // Dmv is a named constant
int var = 17;                        // var is not a constant
const double sqv = sqrt(var);        // possibly computed at runtime

double sum(const vector<double>&);   // sum will not modify its argument

vector<double> v {1, 2, 3, 4, 5};    // v is not an constant
const double s1 = sum(v);            // LEGAL: sum(v) eval. at runtime
constexpr double s2 = sum(v);        // ERROR: sum(v) is !constant exp.
```
for a function to be usable as a *constant expression* meaning it will be evaluated by the compiler, it must be defined as `constexpr` or `consteval`. For example: 
```c++
// continuation of previous code
constexpr double square(double x) { return x*x; }

constexpr double max1 = 1.4*square(17);  // LEGAL: RHS is constant exp.
constexpr double max2 = 1.4*square(var); // ERROR: var is !constant
const double max3 = 1.4*square(var);     // LEGAL: may eval. @ runtime
```
A `constexpr` ***function*** can be used in non-constant argument; when this happens its result is not a constant expression.
### `consteval`
When we want a function to only be evaluated at compile time, we declare it `consteval` rather than `constexpr`, an example:
```c++
// coninuation of previous code
consteval double square2(double x) { return x*x; }

constexpr double max1 = 1.4*square2(17);   // LEGAL: RHS is constant exp.
const double max3 = 1.4*square2(var);      // ERROR; var is !constant
```

## Pure functions
`constexpr`and `consteval` functions are c++ versions of pure functions. They cannot have side-effects and can only use info. passed into them as arguments. In particular they cannot modify non-local variables.

compile-time evaluation is important for performance. Independent of performance issues, the notion of immutability is an important design concern.

## 1.7 Pointers, Arrays and References
The size of an array must be a constant expression:
```c++
char v[6]; // array
char* p;   // pointer to character

char* p = &v[3];  // pointer to the v's fourth element
char x = *p       // *p is the object p points to
```

### range-`for`-statement
It is a simpler for statement, that traverses a sequence of elements. 
```c++
int main() 
{
	 int vec[] = {1, 2, 3, 4 5 ,6};

	for (auto i : vec)
		cout << i << '\n';

	for (auto x : {10, 92, 33, 32, 61, 13, 64,})
		cout << x << '\n';
}
```
If we require to only refer to the elements we, could:
```c++
void increment()
{
	int v[] = {1, 2, 3, 4, 5, 7};

	for (auto& i : v)
		++v;
}
```

Things to note:
1) In an expression, prefix unary `*` means “contents of” and prefix  unary `&` means “address of”.
2) In a declaration, the unary suffix `&` means “reference to”. A reference is similar to a pointer except you don’t need to use a prefix `*` to access the value referred to by the reference.
### References
1) A reference cannot be made to refer to a different object after its initialization
2) References allow us to refer to a object while allowing its name (the name of the reference) to used the same semantics the name of the actual object would allow: A reference can be treated the same as the object it refers to.
References eradicates cost of copying in functions, for example:
```c++
void sort(vector<double>& v);

int func()
{
	Vector<double> my_vec {1.0, 2.0, 3.0, 4.0};
	sort(my_vec)
}
```
in the above snippet, the call `sort(my_vec)` does not copy `my_vec`. it really is `my_vec` being handled in the function, just through a reference.

### constant reference
When we don’t want to modify an argument but still don’t want the cost of copying, we use a `const` reference, that is a reference to a const. An example:
```c++
double sum(const vector<double>&);
```

## 1.7.1 The Null Pointer
When we don’t have an object for a pointer to point to, or need to establish the notion of “no object available”, we give the pointer the value `nullptr`, there is only one `nullptr` shared by all pointers types:
```c++
double* pd = nullptr;
Link<Record> lst = nullptr;
int x = nullptr;
```

## 1.8 Tests
C++ provides a conventional set of statements for expressing selection and looping, such as, switches, while loops and for loops.

```c++
bool accept() {
	cout << "Do you want to procees y/n?\n";
	char answer = 0;
	cin >> answer;

	if (answer == 'y')
		return true;
	return false;
}
```
Note that the definition of answer appears where it is needed (and not before that). ==A declaration can appear wherever a statement can==

### Switches
A switch statement tests a value against a set of constants. Those constants, called `case`-labels, must be distinct and if the tested does not match any of them, the default is chosen, if a break is not declared in the body of matched case, execution will not stop at that case, and the next cases following the matched case, will also be executed.
```c++
void acton()
{
	while (true) {
		cout << "enter action:\n";
		string act;
		cin >> act;
		Point delta {0, 0};

		for (char ch: act) {
			switch(ch) {
			case 'u': // up
			case 'n': // north
				++delta.y;
				break;
			case 'r': // right
			case 'e': // east
				++delta.x;
				break;
			default:
				cout << "i freeze\n";
			}
			move(current+delta*scale);
			update_display();
		}
	}
}
```

Things to Note:
1) Just like a for statement an if statement can introduce a variable and test it:
```c++
void do_something(vector<int>& v)
{
	if (auto n = v.size(); n!= 0){
		// do some'n
	}
}
```

2) The most common case is testing a variable against 0 (or a `nullptr`), to do that, simply leave out the explicit mention of the condition. For example:
```c++
void do_something(vector<int>& v)
{
	if(auto n = v.size()) {
		// get here  is n!=0 or nullptr
	}
}
```

## 1.9 Mapping to Hardware
C++ offers direct mapping to hardware. when we use the fundamental operations, the implementation is what the hardware offers.

C++ array is basically an abstraction of a “contiguous sequence of objects in memory”.

## 1.9.1 Assignment
An assignment of a built in type is a simple machine copy operation.

Unlike in Java and C# where assigning a value to an object makes the object refer to said value, such is not the case in c++; if we want different objects to refer to the same value, we must say so:
```c++
int x = 2;
int y = 3;
int* p = &x;
int* q = &y;
p = q;         // p not points to the address of y 
```
A reference and a pointer both refer/point to an object and both are represented in memory as a machine address. However, the language rules for using them differ. Assignment to a reference does not change what the reference refers to but assigns to the referenced object
```c++
int x = 2; 
int y = 3;
int& r  = x;
int& r2 = y;
r = r2;         // read through r2, write through r: x becomes 3.
```

## 1.9.2 Initialization
Initialization differs from assignment. In general, for assignment to work correctly, the assigned to object must already have a value.

But the goal of initialization on the other hand is to make an uninitialized piece of memory into a valid object.

For almost all types, reading and writing form an uninitialized variable is undefined.

```c++
int x = 7;
int& r{x};
r = 8;

int& r2;  // ERROR; uninitialized reference
r2 = 99;  // assign to whatever r2 refers to
```
in C++, we cannot have uninitialized references. References can uses `=` to initialize, but its should not be confused as a copy, Its initialization.
```c++
int& r = x;
```

