 A `range` is a generalization of the c+98 sequences, defined by `[begin, end]` pairs; it defines what it takes to be a sequence of elements.

A range could be defined by:
* `[begin, end]`→ symbolizing the beginning and ending of a sequence via iterators.
* `[begin, n]` → where begin is an iterator and n is the number of elements
* `[begin, pred]` → where begin is an iterator and, `pred`is a predicate that validates following elements. If `pred(p)`(where p is an iterator) is true, then we have reached the end of the sequence.

The range concept is what makes `range(v)` possible instead of doing `range(v.begin(, v,end())`:

```c++
template<forward_range C>
	requires sortable<iterator_t<R>>
void my_sort(C& cc)
{
	return my_sort(cc.begin(), cc.end());
}
```
Ranges allow us for a more direct expression of something. There are different kind of ranges modeled for different types of iterators.

`input_range`, `forward_range`, `bidirectional_range`, `random_access_range` and `contiguous_range` are all `concepts`.

## 14.2 Views
A view is a way of looking at a range:
```c++
void user(forward_range auto& r) 
{
	filter_view v {r, [](int x) -> bool { return x%2; }} // view onæy odds
	//..
	cout << "odd numbers: ";
	for (auto x: v)
		cout << x << ' ';
}
```
`Filter_view` reads from the range, elements validated by the predicate are returned and while the others are skipped.

Ranges could be infinite; so there are many ranges that take in a limit of elements to view; `take_view` does this.
```c++
void user(forward_range auto& r)
{
	filter_view fv {r, [](int x)->bool {return x&2;}}
	take_view tv {r, 100};   // caps element read to a hundred

	cout << "odd numbers: ";
	for (int x: tv)
		cout << x << ' ';
}
```
`fv` and`tv` readings are synonymous to:
```c++
// fv
for(int x: filer_view{r, [](int x) >bool { return x%2 }})
	cout << x << ' ';

for(int x: take_view{r, 100})
	cout << x << ' ';
```
______
Nesting of view can get cryptic so there are alternatives (solutions if you will): pipelines. std provides many view, also known as range adaptors. View offer interfaces quite similar to ranges, we could use a view wherever we would want a range and vice versa. Difference is that a view does not own its elements; that responsibility belongs to the range itself (deleting elements). A view must not outlive its range:
```c++
auto bad()
{
	vector v {1,2,3,4};
	return filer_view{v, odd};  // v will be destroyed.
}
```
Views are cheap to copy.

```c++
struct Reading {
	int location {};
	int temperature {};
	int humidity {};
	int air_pressure {};
	//..
};

int average_temperature(vector<Reading>& readings)
{
	if (raeading.size()==0) throw No_readings{};
	double s = 0;;
	for (auto x: views::elements<1>(readings))
		s += x;
	return s/readings.size();
}
```
## 14.3 Generators
Generators (aka *factories*) *generate* ranges on the fly. 

Generator examples.`v` is a view; `x` is of element type `T`; `is` is an `istream`:
* `v=empty_view<T>{}`         → empty range.
* `v=single_view{x}`           → range of one element `x`.
* `v=iota_view{x}`               → ∞ elements, `x, x+1, x+2, ...` increment via `++
* `v=iota_view{x,y}`           → via is a range of `n` elements: `x, x+1, ..., y-1`
* `v=istream_view<T>{is}`  → range obtained by calling `>>` for T on `is`

`iota_views`: generating simple sequences:
```c++
for (int x: iota_view(42, 52))  // 42 ... 51
```
`istream_view`: simple way of using `istreams`in range-for loops
```c++
for (auto x: istream_view<complex<double>>(cin))
```
Like other views, a `istream_view` can be composed with other views:
```c++
auto cplx = istream_view<complex<double>> {cin};

for (auto x: transfrom_view{cplx, [](auto z){return z*z;}})
	cout << x << '\n';
```

## 14.4 Pipelines

For each standard library view, std provides a function that produces a filter; meaning an object can be used as an argument to the filter operator `|`. For example, `filer()` yields `filter_view`, this allow us to combine filters in a sequence rather than a set of nested function calls.

```c++
void use(forward_range auto& r)
{
	auto odd = [](int x)->bool{ return x%2; };
	
	for (int x: r | views::filter(odd)) | views::take(3))
		cout << x << ' ';
}
```
Output:
```bash
1 3 5
```
Pipelining uses the same semantics for unix pipelines to perform function calls. It executes from left to right meaning: for `f|g`, `f` is first evaluated and passed on to `g` as an arguments .: → $(g\_filter(f))$, so `f|g|r` is synonymous to $(r\_filter(g\_filter(r)))$. `r` must be a range or generator.

These filter functions are in namespace `ranges::views`.

The implementation of views and pipelines involves hair-raising template metaprogramming, so if concerned about performance; measure. but there is a workaround:
```c++
void user(forward_range auto& r)
{
	int count = 0;
	for (int x: r)
		if (x%2) {
			cout << z << ' ';
			if (++count == 3) break;
		}
}
```

## 14.5 Concepts Overview
There are (in `std`):
* Concepts defining properties of types
* Concepts defining iterators
* Concepts defining ranges

Felix if you want a list of concepts, consult [cppreference](https://cppreference.com), or re-read the section.
 ___________________
### `friend` declarator
`friend` enables us overload binary operators inside a class’s scope. An example of a sentinel for C style strings using `friend`:
```c++
template <class iter>
class Sentinel {
	iter_value_t<const char*> end;
public:
	Sentinel(char e): end{e} {}
	Sentinel(): e{0} {};

	friend operator==(const iter& p, Sentinel s){ return (*p == s.end); }
	friend operator!=(const iter& p, Sentinel s){ return !(p=s); }
};

// check if Sentinel meets the requirement for a `const char*`
static_assert(sentinel_for<Sentinel<const char*>, const char*>);

// use
int user()
{
	const char aa[] = "Hello, World\nBye for now\n";

	ranges::for_each(aa, Sentinel<const char*>{'\n'},
		[](const char x){cout << x;});
}
```
The output will be:
```bash
Hello, World!
```

A sentinel is basically a fancy delimiter for a sequence`<T>`.

## 14.6 Advice
* Pipelines of operations on a range can, be expressed using `views`, `generators`, and `filters`.
* To end a range with a predicate, you need to define a sentinel
* Using `static_assert` we can check that specific types meets the requirement of a concept.
* If you want a range algorithm and there isn’t one in standard, write your own.
* The ideal of types is `regular`
* Prefer std concepts where applicable