A template is a class or function we parameterize with a set of types or values. Templates are use to model a generalized object or entity.

## 7.2 Parameterized Types
We can generalize our vector class as so:
```c++
template <typename T>
class Vector {
private:
	T* elem;
	int sz;
public:
	explicit Vector(int s);
	~Vector() { delete[] elem; }
	
	// copy and move operations.
	
	T& operator[](int i);             // non-const vecs.
	const T& operator[](int i) const; // const vecs.
	int size() const { return sz; }
};
```
using `class` to introduce a type parameter is equivalent to using `typename`, so line 1 can be written as `template <class T>`

The member functions can be defined similarly as:
```c++
template <typename T>
Vector<T>::Vector(int s)
{
	if(s<0)
		throw length_error("Vector constr.: -ve size");
	elem = new T[s];
	sz = s;
}

template <typename T>
const T& Vector<T>::operator[](int s) const
{
	if (s < 0 || s >= sz)
		throw out_of_range("Vector::operator[]");
	return elem[s];
}
```
Given these definition of the vector class we can define vectors as so:
```c++
Vector<char> vc(200);
Vector<list<int>> vli(45);
```

## Grant container `range-for-loop` feature
To support the range-for-loop of our `Vector`, we must define suitable `begin()` and `end()` functions:
```c++
template <typename T>
T* begin(Vector<T>& x)
{
	return &(x[0]);
}

template <typename T>
T* end(Vector<T>& x)
{
	return &x[0]+x.size();  // one pointer past last element.
}
```
Given those we can write:
```c++
void write2(vector<string>& vs)
{
	for(auto& s: vs)
		cout << s << '\n';
}
```
Templates are compile-time mechanism, so their use incurs no run-time overhead compared to hand crafted code.

## 7.2.1 Constrained Template Arguments
Often , template will make sense only for template arguments that meet a certain criteria. For example , `Vector` class offer copy operation and so template argument types that do no support such operations will render the `Vector` class errorneous. 

To solve this we must specify that `Vectors` template arguments is not just a `typename` but an `Element` that satisfies the requirements for a `Vector` class:

```c++
template <Element T>
class Vector {
private:
	T* elem;
	int sz;
}
```
in `template<Element T>` ; `Element` is a predicate that checks whether T has all the properties that a `Vector` requires. Such a predicate is called a *concept*.

A template argument in which argument for which a concept is specified is called a **constrained argument**.

It is a compile error to try to use a template with a type that does not meet its requirements. For example:
```c++
Vector<int> v1;     // Ok we can copy int.
Vector<thread> v2;  //ERROR; we can't copy a standard thread.
```
C++ did not officially support concepts before c++20.

Concepts lest the compiler do type checking at the point of use. giving better error messages far earlier than is possible with unconstrained template arguments.

## 7.2.2 Value Template Arguments
In addition to type Arguments, a template can take Value arguments:
```c++
template <typename T, int N>
struct Buffer{
	constexpr int size() { return N; }
	T elem[N];
}
```
Template Value arguments allow us to create things like arbitrarily sized buffers with no use of the free store:
```c++
Buffer<char, 1024> glob;

void fct()
{
	Buffer<int, 10> buf;
}
```
Unfortunately for obscure technical reasons, a string literal cannot yet be a template value argument. Fortunately a workaround is defined below:
```c++
template<char* s>
void out() { cout << s; }

void use() {
	out<"Straightforward use">();  // ERROR
	// string literal cannot be value arg.

	char[] str = "Workaround use";
	out<str>(); // LEGAL: writes.
}
```

## 7.2.3 Template Argument Deduction
When defining a type as an instantiation of a template we must specify its template argument:
```c++
pair<int, double> p = {1, 5.2};
```
having to specify the template argument types can be tedious; fortunately the constructor can deduce the template arguemnts type from an initializer:
```c++
pair = {1, 5.2};
```
an example with containers:
```c++
template <typename T>
class Vector {
public:
	Vector(int);
	Vector(initializer_list<T>);
	// ..
};

Vector v1 {1, 2, 3};          // type deducted
Vector v2 = v1;               // type deducted fromm v1
auto p = new Vector{1, 2 ,3}; // p is Vector<int>
Vector<int> v3(1);            // here we need to be 
// specific about the template argument type since this
// object is constructed using the Vector(int) constr.
```
Although  type argument deduction eliminate syntactical annoyances, it is not a panacea, it can cause surprises in some cases:

![typedeductionsurprises](src/imgs/typedeductionsurprises.png)

if elements of an initializer list have different types, we cannot deduce a unique element type so we get an ambiguity error. Consider:
```c++
template <typename T>
class Vector {
public:
	Vector(initializer_list<T>);
	
	template<typename Iter>
		Vector(iter b, iter e);
	
	struct iterator { using value_type = T; /*...*/ };
	iterator begin();
};

Vector v1{1, 2, 3, 4, 5};                  // element type: int
Vector v2(v1.begin(), v.begin()+2);        // ambiguous
Vector v3(9, 17);                          // ambiguous
```
We could resolve these using *concepts* but for compatibility with older code: we can add a *deduction guide*:
```c++
template<typename Iter>
	Vector(Iter b, Iter e) -> Vector<typename Iter::value_type>;
```
Now we have:
```c++
Vector v1{1, 2, 3, 4 ,5};              // element type is int
Vector v2(v1.begin(), v1.begin()+2);   // pair of iters. of elem type int
Vector v3{v1.begin(), v1.begin()+2};   // elem type is v2::iterator.
```
Type deduction in this case works because we established that when iterators are used as arguments while `()`constructing a vector: The type of the Vector to be constructed is type of the elements the iterator iterates.

It works in this scenario because we have defined that an iterator posses an aggregated relationship with what type of element the iterator iterates.

Also the `{}` initialization syntax always prefers the `initializer_list` constructor if present. That’s why `v3`is a vector of iterators: `Vector<Vector<int>::iterator>`

## 7.3 Parameterized Operations
There are three ways of expressing an operation parameterized by types or values:
* A function template
* A function object: an object that can carry data and be called like a function
* A lambda expression: a shorthand notation for a function object'

## 7.3.1 Function Templates
an example:
```c++
template<typename Sequence, typename Value>
Value sum(const Sequence& s, Value v)
{
	for(const auto& x: s)
		v+=x;
	return v;
}
```
It can be used as so:
```c++
void user(Vector<int>& vi, list<double>& ld, vector<complex<double>>& vc)
{
	int x = sum(vi, 0);
	double d = sum(vi, 0.0);
	double dd = sum(ld, 0.0);
	auto z = sum(vc, complex{0.0, 0.0});
}
```
This `sum()` is a simplified version of the standard-library `accumulate()`

## 7.3.2 Function Objects
A particular useful kind of template is the *function object* (sometimes called a *functor*); It define objects that can be called like functions:
```c++
template<typename T>
class Less_than {
	const T val;
public:
	Less_than(const T& v): val{v} {}
	bool operator()(const T& x) const { return x<val; }
}
```
The function called `operator()` implements the *application operator*, also called “function call” or just “call”.
We can define named variables of type `Less_than` for some arg types:
```c++
Less_than lti {42};
Less_than lts {"Backus"s};
Less_than<string> lts2 {"Naur"};
```
we can call such an object, just like a function call:
```c++
void fct(int n, const string& s)
{
	bool b1 = lti(n);      // true if n<42
	bool b2 = lts(s);      // true if s<"Backus"
}
```
Function objects are widely used as arguments to algorithms, they can serve as a predicate to a set of values.
```c++
template <typename C, typename P>
int count(const C& container, P predicate)
{
	int count = 0;
	for(const auto& x: container)
		if (predicate(x)) 
			++count;
	return count;
}
```
A *predicate* is something that we can invoke to return true or false. An example:
```c++
void f(const Vector<int>& vec, const list<string>& lst, 
		int x, const string& s)
{
	cout << "number of values less than " << x << ": " << 
		count(vec, Less_than{x}) << '\n';
	cout << "number of values less than " << s << ": " <<
		count(lst, Less_than{s}) << '\n';
}
```
Since simple object functions inlining are also simple, it makes it far more efficient than an indirect function call. The ability to carry data plus their efficiency makes function objects particularly useful as arguments to algorithms.

## 7.3.3 Lambda Expressions
There is a notation for conveniently generating function objects:
```c++
void f(const Vector<int>& vec, const list<string>& lst, 
		int x, const string& s)
{
	cout << "number of values less than " << x
		 << ": " << count(vec, [&](int a){ return a<x; })
		 << "\n";
}
```