Pointers provides a very effective abstraction for representing machine code addresses. It used effectively proves to be very practical, but handling things like resource ownership and such can be quite difficult, them being “bare pointers“, hence they are highly susceptible to misuse. 

To prevent this misuse, The std library provides another layer abstraction that encapsulate the actual pointers in classes. Classes that provide operations to enforce proper usage of the pointers, mechanisms to manage their lifetime and facilities that ensure effective usage. These classes are tailored to achieve specific performance goals.

These pointers are known as “smart pointers”.

## 15.2 Pointers
A pointer is simply something that allows us refer to an object of some type.

Pointer types:
* `T*`                       →     Built, in pointer type, points to object of T
* `T&`                       →     A built in reference type
* `unique_ptr<T>`   →     An owning pointer to T

* `shared_ptr<T>`   →     Pointer to object of type T, ownership is shared among all `shared_ptr`s to that T

* `weak_ptr<T>`       →     Pointer to an object owned by `shared_ptr`; must be converted to `shared_ptr` to access the object

* `span<t>`               →    A pointer to a contiguous sequence of `T`s
* `string_view<T>`  →    A pointer to a `cont` sub-string

* `X_iterator<C>`    →     A sequence of elements from `C`; X in the name indicated the kind of iterator.

### What is an owning pointer?
Multiple pointer can point to an object, But an *owning* pointer is one that is responsible for eventually deleting the object it refers to. A *non-owning* pointer can *dangle*.

### Guidelines to avoid pointer problems (like reading or writing to dangling pointer)
* Don’t retain pointer to a local object after the object goes out of scope. In particular never, return them; systemic usage of containers and algorithms prevent this.
* Use owning pointer to objects allocated in the free store.
* Pointer to static objects (e.g global variables) can’t dangle.
* Leave pointer arithmetic to resource handlers (eg. vectors)
* string views and spans are kinds of non owning pointers


## 15.2 `unique_ptr` and `shared_ptr`
Standard library components are designed not to leak resources. To do this they rely on the basic language resource management using constructors/destructors to ensure resources don’t outlive an object responsible for it.

This approach interacts correctly with error handling using exceptions for example:
```c++
mutex m:

int f()
{
	scoped_lock lck {m};   // acquire the mutex
} // unlocks mutex whether when returning or if an exception is thrown.
```
A thread will not proceed until `lck` acquires the `mutex`. The corresponding destructor releases the `mutex`, when the thread of control leaves f(), either through a `return` or through an exception throw. This is the beauty of RAII, resource management is always performed to prevent leaking resources.

To handle object allocated from the free store; std provides two “smart pointers”:
* `unique_ptr`→ unique ownership (its destructor destroys its object)
* `shaeed_ptr`→ shared ownership, (last shared pointer destructor, destroys the object).
______
### Demonstration of `unique_ptr` and the flaw of `new` bare pointers
```c++
void f(int i, int j)
{
	X* p = new X;              // allocate a new X
	unique_ptr<X> up = new X;  // allocate a new X; bind to a unique_ptr

	if (i<99) throw Z{};
	if (j<77) return;

	delete p;
}
```
In this program; if the first or second conditional execute, `delete p` will never execute, resulting to memory leak, but `up`, no matter how the function terminates `unique_ptr` handles the lifetime of its object and destroys it.

`unique_ptr` is a lightweight mechanism and offers no space or time overhead, its further uses include passing free-store allocated objects in and out of functions:
```c++
unique_ptr<X> make_X(int i)
{
	return unique_ptr<X>{new X{i}};
}
```
It provide move semantics.
________
### Note on shared pointers `shared_ptr`

They are similar to `unique_ptr`s, just that they are copied rather than moved.  They share ownership of an object that is only destroyed when the last `shared_ptr` is destroyed:
```c++
void f(shared_ptr<fstream>);
void g(shared_pyr<fstream>);

void user(const string& name, ios_base::openmode mode)
{
	shared_ptr<fstream> fp { new fstream{name, mode} };
	if (!*fp) throw No_file{};

	f(fp);
	g(fp);
	//..
}
```
`shared_ptr` is neither cost free nor exorbitantly expensive, but it does make the lifetime of a shared pointer quite unpredictable. It should only be used when shared ownership is required.

passing pointers to s smart pointer can be verbose in some cases, and it might lead to mistakes like forgetting to pass a pointer or passing a pointer to an object not on the free store to a `shared_ptr` . To avoid such problems, std library in `<memory>` provides funcs. for constructing an object and returning an appropriate smart pointer:
* `make_shared()` and `make_unique()`
```c++
struct S {
	int i;
	string s;
	double d;
};

auto up = make_unique<S>(10, "rosé", 19.2); // up is unique_ptr
auto sp = make shared<S>(01, "josé", 2.18); // sp is shared_ptr
```
These pointer gives us a chance to enforce a “no naked `new`” policy. However these smart pointers are still basically pointers and should remain an alternative option when we’ve no reason to use the plethora of resource handles (containers) provided by the std library.

So when do we use “smart pointers” rather than resource handlers? the answer: when we need pointer semantics:
* When we share an object, we nee pointers to refer to the shared object, so; `shared_ptr`. unless there is an obvious singular owner.
* When we refer to polymorphic object. We need a pointer because we don’t know the exact object being referred to in the class hierarchy. `unique_ptr`becomes a better choice here.
* shared polymorphic objects require `shared_ptrs`
we don’t need pointer to return a collection of objects; containers do that.

## 15.22 `span`
Span is a resource handle that basically represents a pointer and size; a size that denotes the number of elements the pointer is expected to be continuously linked with. I don’t fully get its use but bjarne says its further enforces the fail-safes against range errors, fail-safes like range-for containers and algorithms and spans add an extra layer of fidelity against range errors.

It is a pointer and length pair that denotes a sequence. It owns none of the object it points to:
`
```c++
void fs(span<int> p)
{
	for(int& x: p)
		x = 0;
}

void use(int x)
{
	int a[100];
	fs(a);               // implicitly creates span<int{a,100}>
	fs(a, 1000);         // error, span expected
	fs({a+10, 100});     // range error in fs
	fs({a,x});           // crap
}
```
span just creates an extra layer that separates potentially “unstable” resource handles (handles with no mechanism that prevents errors and enforce efficacy), from direct usage. This indirect usage helps prevent range errors.

## 15.3 Containers

| Containers        | Description                                                         |
| ----------------- | ------------------------------------------------------------------- |
| `T[N]`            | Built in array; fixed size; contiguously allocated                  |
| `array<T,N>`      | Fixed size contiguously allocated sequence                          |
| `bitset<N>`       | fixed size sequence of `N` bits                                     |
| `vector<bool>`    | A sequence of bits compactly stored in a specialization of `vector` |
| `pair<T,U>`       | Two elements of type `T` and `U`                                    |
| `tuple<T...>`     | A sequence of arbitrary number of elements of arbitrary types       |
| `basic_string<C>` | sequence of characters of types C;                                  |
| `valarray<T>`     | An array of numeric values of type `T`                              |
|                   |                                                                     |
|                   |                                                                     |
* `pair` and `tuple` are heterogeneous, others are homogeneuous
* `array` and `tuple` are contiguously allocated
* `list` and `map` are linked structures
* `bitset` and `vector<bool>` hold bits and access the via proxy objects;
* `basic_string` requires its elements to be some form of character and to provide string manipulation.
* `valarray` requires its elements to be numbers and to provide numerical operations

## 15.3.1 `array`
`array`, defined in `<array>`, is a fixed-size sequence of elements given type where the number of elements is specified at compile time, thus its can be allocated in static storage. It should be basically understood as a built in array with its size firmly attached, no implicit surprising conversion to pointer types and a few convenience function are made available.

There is no space-time overhead compared to using a built in array. Its a safer version of a built in array.

It must be initialized by a initializer list:
```c++
array<int, 3> arr = {1, 2, 3};
```
The number of element in the initializer must be equal or less than the size specified for the array. Element count is not optional; its must be a constant expression and positive, The type of element must also be explicitly stated.

If you need the element count to be a variable→ use a vector numbskull.

Where needed an `array` can be **explicitly** passed to a C-style function that expects a pointer, for example:
```c++
void f(int* p, int sz);

void g()
{
	array<int, 10> a;

	f(a, a.size());         // error: no conversion
	f(a.data(), a.size());  // C-style use

	auto p = finds(a, 777);
}
```
why would we prefer an `array` to a `vector`? this is because an array is a simple structure than a vector which can be helpful in performance critical environments, and the fact that the size of an `array` is that its elements are allocated on stack rather than the free-store which can be quite performative in contrast to vectors that its elements are allocated on the free store.

On the other hand the stack is a limited resources (especially in embedded systems), and stack overflow is nasty. Some application areas, like safety-critical real time control, free store allocation is banned.


An `array`, in contrast to a built in array, knows its size, and can be copied.
```c++
array<int,3> a1 = {1, 2, 3};
auto a2 = a1;  // copy
a2[1] = 5;
a1 = a2;
```

`arrays` also prevent nasty conversions to pointer :
```c++
void h()
{
	Circle a1[10];
	array<Circle,10> a2;
	// init both
	//..
	Shape* err = a;    // Ok: disaster waiting to happen
	Shape* gut = a2;   // error; no implicit conversion to pointer (GOOD)
	err[3].draw();     // DISASTER
}
```
Disaster happens because `err` assumes the `sizeof(Shape)<sizeof(Circle)`, so it deferences at an offset that is invalid.

## 15.3.2 `bitset`
Aspects of a system , such as the state of an input stream, are often represented as a set of flags, indicating binary conditions such as good/bad, true/false and on/off.

class such as `bitset<N>` generalizes this notion by providing operations on a sequence of `N` bits . `N` must be known at compile time. For smaller sets `bitset` is usually optimized. use a set or enumeration if we want to name the bits.

```c++
bitset<9> bs1 {"110001111"};
bitset<9> bs2 {0b1'1000'1111};
bitset<9> bs3 = ~bs1;            // complement -> 001110000
bistet<9> bs3 = bs1&bs3;         // all zeros
bitset<9> bs5 = bs1<<2;          // 000111100
```
the `to_ullong()` and `to_string()` provide the inverse operations to the constructors:
```c++
void use(int i)
{
	bitset<8*sizeof<int>> b {i};
	cout << b.to_string() << '\n';
}
```
`bitset` also provides an output operator so calling the `to_string()` was not necessary.

## 15.3.2 `pair`
A pair is generic object that holds two values (usually of different types.) the first member is named `first` and the second is `second`:

```c++
pair<*Entry, Error_code> complex_search(vector<Entry>& v, const string& s)
{
	Entry* found = nullptr;
	Error_code err = Error_code::failed;
	// search
	//..
	return {found,err};
}

void user(const string& s)
{
	auto[ptr, success] = complex_search(entry_table, s);
	if (success != Error_code::good) {
		// handle error
	}
	// use ptr
}
```
we can use structured binding to rename the return of a pair to names we want.
`paur` belongs to `<utility>`. When code doesn’t need to be generic, a simple struct with named members often leads to more maintainable code.

Type deduction makes it easy to create a `pair` without explicitly mentioning its type.

A pair provides operators such as such, if its elements do.

## 15.3.4 `tuple`
Tuples enable us trear heterogenous objects as a single object. The standard library provides its as a generalization of a `pair` with zero or more elements:
```c++
tuple t0 {};                                         // empty
tuple<string, int, double> t1 {"Shark", 123, 3.14};  // valid
auto t2 = make_tuple(string{"Harold"}, 10, 2.34);    // type deduction
tuple t3 {"cod", 20, 99.9};                          // type deduction
```
members of a tuple are independent, and have no invariant. Members of a tuple are accessed through a `get()` function template:
```c++
string fish = get<0>(t1);
int count = get<1>(t1);
double price = get<2>(t1);
```
the index arguments to the get function must be a constant. `get` is a template function.

element in a tuple with a “unique” type can be “named” by its type and retrieved via the `get<>()`, the same function can also be used for writing:
```c++
auto fish = get<string>(t1);
auto count = get<int>(t1);
auto price = get<double>(t1);

get<string>(t1) = "Tuna";
get<int>(t1) = 7;
get<double>(t1) = 312;
```
Must uses of tuples are encapsulated implementations of higher level constructs. And its members can be accessed to represent those constructs via structured binding:
```c++
auto[fish, count, price] = t1;
cout << fish << ' ' << count << ' ' << price << '/n'; // read
fish = "Sea Bass";                                    // write
```
-------------
explicitly, iterating over elements in a tuple can be messy, requiring recursion and compile time evaluation of the function body:
```c++
template<size_t N=0, typename... Ts>
constexpr print(tuple<Ts...> tup)
{
	if constexpr (N<sizeof...(Ts)) {
		cout << get<N>(tup) << ' ';
		print<N+1>(tup);
	}
}
```

## 15.4 Alternatives
The standard offers three types to express alternatives

| Alternatives  | Description                                                      |
| ------------- | ---------------------------------------------------------------- |
| `Union`       | A built in type that hold one of  a set of alternatives          |
| `variant<T…>` | One of a specified set of alternatives (in `<variant>`)          |
| `optional<T>` | A Value of type T or no value (in `<optional>`)                  |
| `any`         | A value one of an unbounded set of alternative types  in `<any>` |
## 15.4.1 `variant`
A `variant<A,B,C>` is often a more convinient and safer alternative to using unions: An example is a case when we either want a string or an error code:
```c++
variant<string, Error_code> get_message(istream& a)
{
	message m;
	// do some stuff and initialize message
	if (no_problems)
		return message;
	else 
		return Error_code{some_problem};
}
```
After we initialize a `varaint` with a value we can later check what type is the value and retrieve the actual value:
```c++
void user()
{
	auto p = get_message(cin);
	if (holds_alternative<string>(p))
		cout << get<string>(p) << '\n';
	else {
		auto err = get<Error_code>(p);
		//handle error
	}
}
```
the `get<>()`functions can also be used on `variants`. This style is popular with people who do not like exceptions.

here is a situation when the compiler would need to distinguish between different kinds of nodes with different representations:
```c++
using Node = variant<Expression, Statement, Declaration, Type>;

void check(*Node p)
{
	if (holds_alteranative<Expression>(*p))
		Expression& e = get<Expression>(*p);
		
	else if (holds_alternative<Statement>(*p))
		Statement& s = get<Statement>(*p);
	// others for Declaration and Type.
}
```
Bjarne suggest a more cryptic but potentially “faster” alternative to this, i somewhat understand it but my understanding is somewhat foggy:
```c++
using Node = variant<Expression, Statement, Declaration, Type>;

void check(*Node p)
{
	visit( overloaded{
		[](Expression& e) { /* logic for handlling Expression type */},
		[](Statement& s) { /* logic for handling Statement type */ },
		[](Declaration& d) { /* logic for handling Declaration */ },
		[](Type& t) {/* Logic for handling Type uhmm.. types */}
	}, *p);
}

template <class Ts...>
struct overloaded : Ts... {   // inherites them all
	using Ts::operator()...;
};

template<class... Ts>
	overloaded(Ts..) -> overloaded<Ts..>;  // deduction guide
```
The “visitor” `visits` then applies `()` to the `overload` object, which selects the most appropriate lambda to call according to the overload rules. If we try to access a `variant` holding a different type from the expected one, `bad_variant_access` is thrown.

## 15.4.2 `optional`
An `optional<A>` can be seen as a special kind of `variant` (like `variant<A, nothing>`), Or as generalization of `A*` pointing to either an object or being a `nullptr`. Its useful for functions that may not return an object:
```c++
optional<string> compose_message(isstream& is)
{
	string mess;
	// play with string
	if (no_problems)
		return mess;
	return {};
}

// hence we can write
void use()
{
	if(auto m = compose_message(cin))
		cout << *m;               // optional is treated as a pointer
	else
		// handle ERROR.
}
```
This approach appeals to people who do not like exceptions. An `optional` is treated to a pointer to its object rather than the object itself, hence the dereferencing. `optional` equivalent to `nullpte` is the empty object `{}`.

If we try to access an `optional` that does not hold a value, its behavior is undefined; and exception is not thrown. Thus `optional` is not type safe. Don’t try:
```c++
int sum2(optional<int>, optional<int> b)
{
	return *a + *b;   // either (or both) might not be holding a value
}
```

## 15.4.3 `any`
An `any` can hold an arbitrary type and know which type (if any) it holds. It is basically an unconstrained version of `variant`:
```c++
any compose_message(istream& is)
{
	string mess;
	//..
	if (no_prob)
		return mess;
	else
		return erro_number; // int
}
```
`any` remembers the type of the value it was initialized with, we can then extract that value by asserting `any` for the required type:
```c++
auto m = compose_message(cin);
string& s = any_cast<string&>(m);
cout << a;
```
if we try to access an `any` holding a different type than the expected one, `bad_any_access` is thrown.

## Advice
1. A library doesn’t have to be large or complicated to be useful
2. Use `unique_ptr` to refer to objects of polymorphic type.
3. Use `shared_ptr` to refer to shared objects (only)
4. prefer smart pointers to garbage collection
5. prefer `spans` to pointer-plus-count interfaces
6. its supports range-for
7. use `array` when you need a sequence with `constexpr` size 
8. also prefer them over built in arrays
9. Don’t overuse `pair` and `tuple`; named `structs` oft. yields more readable code
10. Use type deduction for pairs and tuples; prevent redundant type specification
11. prefer variants, to explicit use of `unions`
12. consider using `visit` and `overloaded` when selecting among a set of alternatives using a variant; §15.4.1
13. if more than one alternative is possible for `variant`, `optional` or `any`, check the tag before access.
