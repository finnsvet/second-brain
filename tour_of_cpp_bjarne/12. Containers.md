A class with the main purpose of holding objects is commonly called a *container*.

## 12.2 `vector`
A `vector` is a sequence of elements of a given type. The elements are stored contiguously in memory. A typical implementation of `vector` will consist of a handle holding pointers to the first element, one-past-the-last element, and one-past-the-last allocated space.

### Things about vector

* We can initialize `vector` with a set of values of its element type:
```c++
vector<Entry> phone_book = {
	{"Dabvid Hume", 123456},
	{"Karl Popper", 234567},
	{"Bertrand Arthur Russell", 2345678}
};
```
* Elements can be accessed through sub-scripting and Indexing starts at zero
* The vector member `size()` gives the number of elements
* The elements constitute a range, so we can use a range-for-loop:
```c++
void print_book(const vector<Entry>& book)
{
	for(const auto& x: book)
		cout << x << '\n';
}
```
* When vectors are defined, we give it an initial size:
```c++
vector<int> v1 = {1, 2, 3, 4};   // size -> 4
vector<string> v2;               // size -> 0
vector<Shape*> v3(23);           // size -> 23
vector<double> v4(32, 9.9);      // size -> 32, default value -> 9.9
```
* `.push_back()` adds a new element to a vector ans increases its size by one. The standard library is devised such that growing a vector with repeated  `.push_back()` is efficient.
* A `vector` can be copied in assignments and initialization. For example:
```c++
vector<Entry> phone_book = { {"Caligula", 8}, {"Camus", 5} };
vector<Entry> book2 = phone_book;    // this is a copy
```
Assigning a vector involves copying its elements. Thus after initialization of `book2`, `book2` and `phone_book` holds separate copied of every `Entry` in the phone book.

In cases where a vector contains a lot of elements and copying is undesirable, the *move* operations should be used. The `vector` is a very flexible and efficient. It should be used regularly unless there exists a solid reason not to.

## 12.2.1 Elements
When we insert a new element into a vector, the value (dependent on the type the container is instructed to hold) is copied into the container.

If we have a class hierarchy that relies on `virtual` functions to get polymorphic behavior, we should not store objects directly in a container. Instead we should store a pointer (or a smart pointer). An example:
```c++
vector<Shape> vs;          // DONT: no room for a circle or smiley
vector<Shape*> vps;        // better: potential leak though
vector<unique_ptr<Shape>>  // OK.
```

## 12.2.2 Range Checking
* std `vector` does not guarantee range checking. For example:
```c++
void silly(vector<Entry>& book)
{
	int i = book[book.size()].number;
}
```
This initialization is likely to place some random value in i rather tan giving an error. This is undesirable and a common problem. What bjarne does to combat this is using a simple range-checking adaptation of `vector`
```c++
template<typename T>
struct Vec: std::vector<T> {
	using vector<T>::vector; // use the constr. from vector under vec

	T& operator[](int i) { return vector<T>::at(i); }  // range check
	const T& operator[](int i) const { return vector<T>::at(i); } // const

	auto begin() { return Checked_iter<vector<T>>(*this); } // 13.1
	auto end() { return Checked_iter<vector<T>>(*this,vector<T>::end()); }
};
```
`Vec` inherits everything from `vector` except what it redefines to do range chacking. Vector’s `at()` performs a subscript operation that throws an `out_of_range` exception when the range has been exceeded. So now we can catch range check errors:
```c++
void checked(Vec<Entry>& book)
{
	try { book[book.size()] = {"Joe", 999999}; // will throw exception
	}
	catch ( out_of_range&) { cerr << "range error\n"; 
	}
}
```


* Once way to avoid surprises from uncaught exceptions is to use a `main()` with a `try-` block as its body:
```c++
int main()
{
try {
	// your code
}
catch (out of range&) {
	cerr << "range error\n";
}
catch (...) {     // default exception handler.
	cerr << "unknown expception thrown\n";
}
```

The reason why std `vector` do not guarantee range checking is; Many performance critical applications use `vectors` and checking all subscripting implies a cost on the order of 10% (and this can vary dramatically depending on the environment of the application), And experience shows that such overhead can lead users to prefer more unsafe mechanisms like bare arrays.

Bjarne also explains that if we use `vector::at()`, then we do not need to worry ourselves with the struct workaround adaptation of `vector`.

## 12.3 `list`
The standard library offers a doubly linked list called list.

![list](src/imgs/list.png)

We use a `list` for sequences where we want to insert and delete elements without moving other elements, like in a phone book:
```c++
list<Entry> phone_book = {
	{"David Hume", 123456},
	{"Kart Popper", 234567},
	{"Bertrand Arthur William Russel", 345678}
};
```
* Elements in linked list are not accessed via subscripting (like vectors), instead we search the list looking for what we need. An example:
```c++
int get_number(const string& s)
{
	for(const auto& x: phone_book)
		if(x.name==s)
			return x.number;
	return 0;     // use 0 to represent number not found.
}
```
Sometime we need to identify an element in a list to perform some computation related to it (delete/place a new element adjacent to it). To achieve this we use a list *iterator*. 

Every standard library container provides a `begin()`and `end()`, which returns an iterator to the first and one-past-the-last element, respectively, of the container:
```c++
int get_number(const string&s)
{
	for(auto p = phone_book.begin(); p!=phone_book.end(); ++p)
		if (p->name == s)
			return p->number;
	return 0;
}
```
This roughly the way the terser and less error-prone range-for loop is implemented by the compiler.

* Adding/removing elements to/from a `list` is really easy. in `list.insert(p,elem)` inserts an element with a copy of the value `elem` before p. Conversely `erase(p)` removes p and destroys it:
```c++
void f(const Entry& ee, list<Entry>::iterator p, list<Entry>::iterator q)
{
	phone_book.insert(p, ee);  // add ee before the element p refers to
	phone_book.erase(q);       // remove element q refers to
}
```

We should prefer vectors to list (unless in novel cases)

## 12.4 `forward list`
A forward list differs from a (doubly-linked) list only by allowing forward iteration. its point is to save space. The size of an empty `forward_list` is just one pointer. It doesn’t even keep its number of elements, if you need a “size”, you count, if you can’t afford to count, you probably shouldn’t be using a `forward_list`
## 12.5 `map`
This is basically a balanced binary search tree (usually a red-black tree) called a `map`:

![map](src/imgs/map.png)

A map is known as an associative array or dictionary. The standard-library `map` is a container of pairs of values optimized fro lookup and insertion.

*  It can be initialized the same was as vectors and lists
```c++
map<string, int> phone_book {
	{"David Hume", 123456},
	{"Kart Popper", 234567},
	{"Betrand Artur William Russel", 345678}
};
```
When indexed by a value of its first type (the key), a `map` returns the corresponding value of the second type (the value). For example:
```c++
int get_number(const string& s)
{
	return phone_book[s];
}
```
if a `key` isn’t found, it is entered into the `map` with a default value for its `value`. If we want to prevent entering invalid numbers into our phone book, we could use `find()` and `insert()` instead of `[]`.

## 12.6 `unodered map`
cost → `Olog(n)`, where n → number of elements.