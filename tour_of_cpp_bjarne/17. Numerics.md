## 17.2 Mathematical Functions
In `<cmath>`, we find *standard mathematical functions*, such as `sqrt(), log(), and sin()`. The versions of these functions for `complex` are found in `<complex>`. For each of these functions the argument type is the same as the return type.

Most mathematical functions are found in `<cmath>` and `<cstlib>`. *special mathematical functions* are also found in `<cmath>`.

## 17.3 Numerical Algorithms
in `<numeric>`, we find a small set of generalized algorithms, such as `accumulate`. For further referencing Felix, check the book.

An example of one the functions here:
```c++
list<double> lst {1, 2, 3, 4, 5, 9999.99999};
auto sum = accumulate(lst.begin(), lst.end(), 0.0);  // sum
```

## 17.3.1 Parallel Numerical Algorithms
In the same `<numeric>`, there exists parallel algorithms that slightly differ from its sequential counterparts; They allow operations on elements in unspecified order. These parallel algos can take execution policy arguments (`seq`, `par`, `unseq`, `par_unseq`).

For a list of them, check a referencing compendium (cppreference).

An example of a parallel function that takes in an execution policy argument:
```c++
vector<double> v {1, 2, 3, 4, 5, 9999.99999};
auto s = reduce(v.begin(), v.end()); // accumulate using double
//..
vector<double> large;
// fill large
auto s2 = reduce(par_unseq, large.begin(), large.end());
```
Execution policies are hidden in the namespace `std::execution` in `<execution>`

## 17.4 Complex Numbers
The standard library `complex` is a template; in order to support computes for complex numbers whose scalars resolution of precision can be specified, e.g float scalars, or double scalars:
```c++
template <typename Scalar>
class complex {
public:
	complex(const Scalar& re = {}, const Scalar& im = {});
	//..
}
```
Usual arithmetic operations are supported for complex numbers. Functions that operate on complex numbers can be found in `<complex>`

## 17.5 Random Numbers
They are useful in many context, hence are important to be discussed. A wide selection of random number generators can be found in `<random>`. A random number consists of two parts:
1. An *engine*, that produces a sequence of pseudo-random values
2. A *distribution* that maps those values into a mathematical distribution in a range
Examples of distributions:
* `uniform_int_distribution` →   All integers produces are equally likely
* `normal distribution`           →  Bell Curve (Gaussian)
* `exponential_distribution`  →  Exponential Growth

```c++
using my_engine = default_random_engine;
using my_dist   = uniform_int_distribution<>;

my_engine eng  {};                       // default random engine
my_dist   dist {1, 6};                   // distribution mapping 1..6
auto die = [&](){ return dist(eng); };   // a generator

int x = die();                           // die rolled.
```

We can map the implementations for generating a random number into a class as so;
```c++
class Rando_int {
	default_random_engine eng;
	uniform_int_distribution<> dist;
public:
	Rando_int(int b, int e): dist{b, e} {}
	int operator()() { return dist(eng); }
	void seed(int s) { eng.seed(s); }
};
```
usage: [main.cpp](src/chapter-17/main.cpp)
_______________
If we need genuine random numbers, rather than pseudo one, look how `random_device` is implemented on your machine.

## 17.6 Vector Arithmetic
normal `vector` doesn’t support mathematical vector operations. Hence the standard library provides, in `<valarray>`, a `vector` like template called `valarray`. It’s less general and more amenable to optimization for numerical computes.

The usual arithmetic operations and post common mathematical functions are supported for `valarrays`. For example:
```c++
void f(valarray<double>& a1, valarray<double>& a2)
{
	valarray<double> a = a1*3.14+a2/a1;
	a2 += a1*3.14;
	a = abs(a);
	double d = a2[7];
	//..
}
```
The operation are vector operations; they are applied to each element of the vectors involved. It also offers *stride access* (whatever that means) to help implement multidimensional computes.

## 17.7 Numeric Limits
`<limits>`, provides classes that describe the properties of built in types, such as the maximum exponent of a `float`, or the number of bytes in an `int`.
```c++
static_assert(numeric_limits<char>::is_signed, "unsigned characters!");
static_assert(100000<numeric_limits<int>::max(), "small ints!);
```
`numeric_limits<int>::max()` is a `constexpr` function. We can define `numeric_limits` for our own user-defined types.

## 17.8 Type Aliases
If we want to be specific about size of integers we can use aliases defined in `<stdint>`, such as `int32_t` and `usint_least64_t`. Other common ones are `size_t`; the type returned by `sizeof()` and `ptrdiff_t`; the type of the result gotten from subtracting pointers, can be found in `<stddef>`

## 17.9 Mathematical Constants
Mathematical constants are usually templates to support precision specifications to cater for our needs. They come in two forms→ a template that allows us to specify an exact type (`pi_v<T>`), and a short name for the most common use (`using pi = pi_v<double>`).
```c++
void area(float r)
{
	using namespace std::numbers;  // where math.tcl constants are kept

	double d = pi*r*r;
	float f = pi_v<float>*r*r;
	//..
}
```
domain specification when declaring constants:
```c++
template<typename T>
constexpr T tau_v = 2*pi_v<T>;

constexpr double tau = tau_v<double>;
```

## 17.10 Advice
* Don’t try to do serious numeric computations using only bare language; seek a library
* Consider `accumulate()`, `inner_product()`, `partial_sum()` and `adjacent_difference()`, before you write a loop to compute a value from a sequence
* For larger amounts of data, try parallel and vectorized algorithms
* `std::complex` for complex arithmetic
* Bind an engine to a distribution to get a random number generator
* Don’t use C-lib `rand()`; mostly insufficient for real uses 
* Use `valarray` for numerical computes when run-time efficiency is more important than flexibility
* properties of numeric types are accessible via `numeric_limits`
* Use aliased for integers types for size specificity.

