Templates is the cornerstone of *generic programming*, that is, programming focuses on the design, implementation and use of general algorithms. The template is C++ mains support for generic programming.

## 8.1 Concepts
Consider this function `sum()`:
```c++
template <typename Sequence, typename Value>
Value sum(const Sequence& s, Value v)
{
	for(const auto& x:s)
		v+=x;
	return v;
}
```
`sum()` requires that:
* its first template arg. is some kind of sequence of elements
* second template arg. is some kind of number.
being more specific:
* A *sequence* that supports `begin()` and `end()` so that range-for will work.
* An *arithmetic type* that supports += so elements in the sequence can be added.
These requirements are ***concepts***.

## 8.2.1 Use of Concepts
Most template arguments must meet a specific constraint in order for the template to compile and function properly, Meaning most templates are expected to be ***constrained*** and `typename`  is least constraining; since it just demands the argument being plugged into the template parameter must be a `type`; any type will suffice.

We can constrain the the sum() function using concepts.
```c++
template<Sequence Seq, Number Num>
Num sum(const Seq& s, Num v)
{
	for(const auto& x:s)
		v+=s;
	return v;
}
```
Using the `Sequence` and `Number` concepts it makes everything clearer. Now the compiler can reject bad calls by looking as `sum()` interface only, rather than its implementation. This improves error reporting.

We can be more specific by explicitly stating that we should be able to add elements of the `Sequence` to a `Number`:
```c++
template<Sequence Seq, Number Num>
	requires Arithmetic<range_value_t<Seq>, Num>
Num Sum(const Seq& s, Num n);
```
in this specification:
* `range_value_t` is the type of the elements in that sequence.
* `Arithmetic<X,Y>` is concept that specifies we can do arithmetic with numbers of types `X` and `Y`.
in this concept enforcement:
```c++
requires Arithmetic<range_value_t<Seq>, Num>
```
is called a `requirements`-clause, And `template<Sequence Seq>` is a shorthand for `requires Sequence<Seq>`. If we wanted to be verbose we could say:
```c++
template <typename Seq, typename Num>
	requires Sequence<Seq> && Number<Num> &&
		Arithmetic<range_value_t<Seq>, Num>
Num sum(const Seq& s, Num n);
```
On the other hand a more succinct notation can be written as:
```c++
template<Sequence Num, Arithmetic<range_value_t<Seq>> Num>
Num sum(const Seq& s, Num n);
```
whatever notation we choose, its important to design a template with semantically meaningful constraints on its arguments.

## 8.2.2 Concept-based Overloading
Templates can be overloaded via their concepts:
```c++
template<forward_iterator Iter>
void advance(Iter p, int n)
{
	while(n--)
		++p;  // foward iterator has ++, but not + or +=
}

template<random_access_iterator Iter>
void advance(Iter p, int n)
{
	p+=n;     // a random-access iterator has +=
}
```
A list only supplies forward iterators, but a vector offers random-access iterators. so:
```c++
void user(vector<int>::iterator vip, list<string>::iterator lsp)
{
	advance(vip, 10);  // uses fast advance
	advance(lip, 10);  // uses slow advance
}
```
Like other overloading, this is a compile time mechanism implying no run-time cost, in the case where the best choice is not found the compiler throws an ambiguity error.

concept based overloading rules:
* if the argument does’t match the concept, that alternative cannot be chosen
* if the arguments matches the concept for just once alternative, that alternative is chosen.
* If arguments from two alternatives match a concept and one is stricter than the other, that alternative is chosen.
* if arguments from two alternatives are equally good matches for the concept, we have an ambiguity
For an alternative to be chosen:
* a match for all of its arguments, and
* at least an equally good match for all arguments as other alternatives, and
* a better match for at least one argument.
## 8.2.3 Valid Code
The question of whether a set of template arguments offers what a template requires of its template parameters ultimately boils done to whether some expressions are valid. This is done with a `requires`-expression.
```c++
template<forward_iterator Iter>
	requires requires(Iter p, int i) { p[i]; p+i; }
void advance(Iter p, int n)
{
	p+=n;
}
```
The first `requires` starts the requirements-clause and the second `requires` starts the `requires`-expression:
```c++
	requires(Iter p, int i) { p[i]; p+i; }
```
A `requires`-expression is a predicate that is true if the statements in it are valid and false if not. Although this is somewhat useful in very low-level abstraction implementations, It should be avoided unless in novel situations. we should always preference already existing concepts in the standard library or properly named concepts with well defined semantics (8.2.4)

## 8.2.4 Definition of Concepts
It is usually easier and more efficient to use concepts from a good library than to write a new one, but if we wanted to define our own concepts; it is not a hard task:
```c++
template <typename T>
concept Equality_comparable = requires (T a, T b) {
	{ a == b } -> Boolean;
	{ a != b } -> Boolean;
};
```
The `Equality_comparable` concept above enforces the statement: “given the two values of a type we should be able to compare them with `==` and `!=` and the resultant of their comparison must be a boolean” For example:
```c++
static_assert(Equality_comparable<int>);   // succeeds.
struct S { int a; };
static_assert(Equality_comparable<S>); // FAILS: structs dont do != && ==
```
The value of a concept is always `bool`.  `Boolean` simply means a type that can be used as a condition.

If we were to define a concept for non-homogeneous types it would be like this:
```c++
template<typename T, typename T2 = T>
concept Equality_comparable = requires (T a, T2 b) {
	{ a == b } -> Boolean;
	{ a != b } -> Boolean;
	{ b == a } -> Boolean;
	{ b != a } -> Boolean;
};
```
`typename T2 =T`is a default template argument. we can test the above concept as so:
```c++
static_assert(Equality_comparable<int,double>); // succeeds.
static_assert(Equality_comparable<int>); // succeeds. T2 defaults to int.
static_assert(Equality_comparable<int, string>); // Fails.
```
### Defining the Arithmetic Concept
first we need to define the `Number` concept:
```c++
template<typename X, template Y>
concept Number = requires(X a, Y b) {
	a+b; a-b; a*b; a/b;
	a+=b; a-=b; a*=b; a/=b;
	x=x; // copy. 
	x=0;
};
```
This makes no assumption for the resultant of each little statements but it will suffice for simple uses.

Now we define the Arithmetic concept:
```c++
template<typename N1, typename N2=N1>
concept Arithmetic = Number<N1, N2> && Number<N2, N1>;
```
Bjarne give a more complex example that i will not document.

## 8.2.4.1 Definition Checking

The concepts specified for a template are used to check arguments at the point of use of the template. They are not used to check the use of the parameters in the definition of the template.

## 8.2.5 Concepts and `auto`
The keyword `auto` denotes the least constraint concept for a value: the value must be a value of some type. Taking an `auto` parameter makes a function into a function template. Given concepts, we can strengthen requirements by preceding `auto` by a concept. For example:
```c++
auto twice(Arithmetic auto x) { return x+x; }
auto thrice(auto x) { return x+x+x; }

auto x1 = twice(7);           // LEGAL;
auto x2 = twice("Hello"s);    // ERROR: concept violated
auto x2 = thrice("Hello"s);   // LEGAL: function is not constrained.
```
In addition to constraining functions, concepts can constrain the initialization of variables.
```c++
auto ch1 = rando_fct("foo");  // works with whatever rando returns
Arithmetic auto ch2 = rando_fct("foo"); // ERROR: rando doesn't return a "number"
```
For readability and debugging it is often important that a type error is caught as close to its origin as possible. Constraining `auto` return types help with this:
```c++
Number auto some_fct(int x)
{
	//..
	return fct(x);   // error unless fct(x) returns a Number
	//..
}
```
## 8.2.6 Concepts and Types
This section explains further on concepts and types but my key takeaway here is; Concepts should be used as adjectives, rather than a noun, in code since the notational support for them is not yet perfect:
```c++
void sort(Sortable auto&);  // LEGAL: sortable describes auto
void sort(Sortable&);       // ERROR: no "noun" for Sortable to qualify
```

## 8.3 Generic Programming
The process of generalizing form a concrete piece of code (and preferably from several) while serving performance is called *lifting*. Conversely, the best way to develop a template is often to:
1) first, write a concrete version.
2) them, debug, test and measure it
3) finally replace the concrete types with template argument

Consider the function `sum`:
```c++
double sum(const vector<int>& v)
{
	double res = 0;
	for(const auto& x: v)
		res+=x;
	return res;
}
```
Now, following the guide of how to design generic entities, we can write:
```c++
template<forward_range C, Arithemetic<value_type<C>> N>
N accumulate(const C& container, N res=0)
{
	for(const auto x: container)
		res+=x;
	return res;
}
```
A *range* is a standard library concept representing a sequence with `begin()` and `end()`.

## 8.4 Variadic Templates
A template can be defined to accept an arbitrary number of arguments of arbitrary types. such a template is called a *variadic template*. 

Traditionally, implementing variadic template has been to separate the first argument form the rest and them recursively call the variadic template for the tail of the template. A demonstration:
```c++
template <typename C>
concept Printable = requires (C c) { cout<<c; }

void print()
{
	// we do nothin when the print function has no arguemnts
}

template<Printable T, Printable... Tail>
void print(T head, Tail... tail)
{
	cout << head << '';
	print(tail..);
}
```
`Printable...` indicates that `Tail` is a sequence that follows the Printable concept. A parameter declared with `...` is called a *parameter pack*

Bjarne then proceeds to explain a certain variation of this function if we don’t want to allow the zero argument case. I am too hungry to document that.

## 8.4.1 Fold expressions
C++ offers a limited from of iteration over elements of a parameter pack. To simplify the implementation of simple variadic templates. THis form of iteration is known as *fold expressions*. For exanple:
```c++
template<Number... T>
int sum(T...v)
{
	return (v + ... + 0);  // right fold 
}

template<Number... T>
int sum2(T...v)
{
	return (0 + ... + v);  // left fold
}

template<Printable... T>
void print(T&&... args)
{
	(std::cout << ... << args) << '\n';½
}

print("Hello"s, ' ', "World ", 2017);
```
fold was added to c++ in 2017.

## 8.4.2 Forwarding Arguments
Passing arguments unchanged through an interface is an important use of variadic templates. Consider a notion of a network input channel for which the actual 
method of moving values is a parameter. Different transport mechanisms have different set of constructor parameters:
```c++
template<concepts::InputTransport Transport>
class InputChannel {
public:
	//..
	InputChannel(Transport::Args&&... transportArgs)
		: _transport(std::forward<TransportArgs>(transportArgs)...)
	{}
	//..
	Transport _transport;
}
```
The standard library function `forward()` is used to move the arguments unchanged from the `InputChannel constructor` to the `Transport` constructor. Forwarding is very common in foundational libraries where generality an low run-time overhead are necessary and very general interfaces are common.

## 8.5 Template Compilation Model.
not documenting (did read it though)

